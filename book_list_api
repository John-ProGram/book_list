from typing import TypedDict
from flask import Flask, jsonify, request
from datetime import datetime
from flask_sqlalchemy import SQLAlchemy

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'postgresql://postgres:1234@localhost:5432/livros_database'
db = SQLAlchemy(app)

class LivrosData(TypedDict):
    book_name: str
    publisher: str
    published_date: str
    author: str
    isbn: str

class Livro(db.Model):
    __tablename__ = "livros"

    id = db.Column(db.Integer, primary_key=True)
    book_name = db.Column(db.String, nullable=False)
    publisher = db.Column(db.String, nullable=False)
    published_date = db.Column(db.Date, nullable=False)
    author = db.Column(db.String, nullable=False)
    isbn = db.Column(db.String, unique=True, nullable=False)

    def __init__(self, book_name, publisher, published_date, author, isbn):
        self.book_name = book_name
        self.publisher = publisher
        self.published_date = published_date
        self.author = author
        self.isbn = isbn


livros: list[LivrosData] = []


@app.route("/livros", methods=["GET"])
def get_geral():
    livros = Livro.query.all()
    livros_serializados = [
        {
            "book_name": livro.book_name,
            "publisher": livro.publisher,
            "published_date": livro.published_date.isoformat(),
            "author": livro.author,
            "isbn": livro.isbn
        }
        for livro in livros
    ]
    return jsonify(livros=livros_serializados), 200



@app.route("/livros/<string:isbn>", methods=["GET"])
def get_livro_by_isbn(isbn):
    livro = Livro.query.filter_by(isbn=isbn).first()
    if livro:
        return jsonify({
            "book_name": livro.book_name,
            "publisher": livro.publisher,
            "published_date": livro.published_date.isoformat(),
            "author": livro.author,
            "isbn": livro.isbn
        }), 200
    return jsonify({"erro": "Livro não encontrado"}), 404




@app.route("/livros", methods=["POST"])
def create_livros():
    livro_dados = request.get_json()
    print(livro_dados)
    published_date_str = livro_dados.get("published_date", "")
    try:
        book_name = livro_dados["book_name"]
        publisher = livro_dados["publisher"]
        published_date = datetime.strptime(published_date_str, "%Y-%m-%d").date()
        author = livro_dados["author"]
        isbn = livro_dados["isbn"]
        livro = Livro(
            book_name=book_name,
            publisher=publisher,
            published_date=published_date,
            author=author,
            isbn=isbn
        )
        db.session.add(livro)
        db.session.commit()
        return jsonify(msg="Livro adicionado com sucesso"), 201
    except KeyError as error:
        return jsonify({"error": "Chave faltante: " + str(error)}), 400
    except ValueError:
        return jsonify({"error": "Formato de data inválido. Use YYYY-MM-DD."}), 400
    except Exception as error:
        return jsonify({"error": str(error)}), 500
    


@app.route("/livros/<string:isbn>", methods=["PUT"])
def update_livros(isbn):
    livro_dados = request.get_json()
    print(livro_dados)
    published_date_str = livro_dados.get("published_date", "")
    try:
        book_name = livro_dados["book_name"]
        publisher = livro_dados["publisher"]
        published_date = datetime.strptime(published_date_str, "%Y-%m-%d").date()
        author = livro_dados["author"]
        isbn = livro_dados["isbn"]
        livro = Livro(
            book_name=book_name,
            publisher=publisher,
            published_date=published_date,
            author=author,
            isbn=isbn
        )
        db.session.commit()
        return jsonify(msg="Livro alterado com sucesso"), 201
    except KeyError as error:
        return jsonify({"error": "Chave faltante: " + str(error)}), 400
    except ValueError:
        return jsonify({"error": "Formato de data inválido. Use YYYY-MM-DD."}), 400
    except Exception as error:
        return jsonify({"error": str(error)}), 500



@app.route("/livros/<string:isbn>", methods=["DELETE"])
def delete_livros(isbn):
    livro = Livro.query.filter_by(isbn=isbn).first()

    if not livro:
        return jsonify(msg="Livro não encontrado"), 404

    db.session.delete(livro)
    db.session.commit()
    return jsonify(msg="Livro deletado com sucesso"), 404



@app.route("/livros/<string:isbn>", methods=["PATCH"])
def patch_livros(isbn):
    livro_dados = request.get_json()
    livro = Livro.query.filter_by(isbn=isbn).first()

    if not livro:
        return jsonify(msg="Livro não encontrado"), 404

    campos_validos = ["book_name", "publisher", "published_date", "author", "isbn"]

    try:
        for campo, valor in livro_dados.items():
            if campo in campos_validos:
                if campo == "published_date":
                    valor = datetime.strptime(valor, "%Y-%m-%d").date()
                setattr(livro, campo, valor)

        db.session.commit()
        return jsonify(msg="Livro atualizado com sucesso"), 200
    except ValueError:
        return jsonify({"error": "Formato de data inválido. Use YYYY-MM-DD."}), 400
    except Exception as error:
        return jsonify({"error": str(error)}), 500
    

# DATABASE DE AUTORES
class authors_data(TypedDict):
    author_name: str
    birth_date: str
    nationality: str

class author_db_model(db.Model):
    __tablename__ = "autores"
    id = db.Column(db.Integer, primary_key=True)
    author_name = db.Column(db.String, nullable=False)
    birth_date = db.Column(db.Date, nullable=False)
    nationality = db.Column(db.String, nullable=True)

    def __init__(self, author_name, birth_date, nationality):
            self.author_name = author_name
            self.birth_date = birth_date
            self.nationality = nationality

authors: list[authors_data] = []

@app.route("/authors", methods=["GET"])
def get_authors():
    authors = author_db_model.query.all()
    authors_get = [
         {
            "author_name": author.author_name,
            "birth_date": author.birth_date.isoformat(),
            "nationality": author.nationality
         }
         for author in authors
    ]
    return jsonify(authors=authors_get), 200

@app.route("/authors/<string:author_name>", methods=["GET"])
def get_authors_by_name(author_name):
    authors = author_db_model.query.filter_by(author_name=author_name).first()

    if not authors:
        return jsonify({"erro": "Autor não encontrado"}), 404

    authors_get = [
         {
            "author_name": authors.author_name,
            "birth_date": authors.birth_date.isoformat(),
            "nationality": authors.nationality
         }
    ]
    return jsonify(authors=authors_get), 200

@app.route("/authors", methods=["POST"])
def add_author():
     author_data = request.get_json()
     birth_date = author_data.get("birth_date", "")
     try:
        author_name = author_data["author_name"]
        birth_date = datetime.strptime(birth_date, "%Y-%m-%d").date()
        nationality = author_data["nationality"]
        author = author_db_model(
            author_name=author_name,
            birth_date=birth_date,
            nationality=nationality
            )
        db.session.add(author)
        db.session.commit()
        return jsonify(msg="Autor adicionado com sucesso"), 201
     except KeyError as error:
        return jsonify({"error": "Chave faltante: " + str(error)}), 400
     except ValueError:
        return jsonify({"error": "Formato de data inválido. Use AAAA-MM-DD."}), 400


print("Banco conectado:", app.config['SQLALCHEMY_DATABASE_URI'])

with app.app_context():
    db.create_all()

app.run(debug=True)



